// Code generated by protoc-gen-micro. DO NOT EDIT.
// source: proto/inventory.proto

package inventory

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

import (
	context "context"
	api "github.com/micro/micro/v3/service/api"
	client "github.com/micro/micro/v3/service/client"
	server "github.com/micro/micro/v3/service/server"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ api.Endpoint
var _ context.Context
var _ client.Option
var _ server.Option

// Api Endpoints for Inventory service

func NewInventoryEndpoints() []*api.Endpoint {
	return []*api.Endpoint{}
}

// Client API for Inventory service

type InventoryService interface {
	// Reserve the inventory required to fulfil an order
	Reserve(ctx context.Context, in *ReserveRequest, opts ...client.CallOption) (*ReserveResponse, error)
	// Pick inventory for an order. If the order was reserved, the units reserved will now be moved
	// to picked.
	Pick(ctx context.Context, in *PickRequest, opts ...client.CallOption) (*PickResponse, error)
	// Void an order, releasing any inventory reserved or picked for the order.
	Void(ctx context.Context, in *VoidRequest, opts ...client.CallOption) (*VoidResponse, error)
	// UnfulfilableOrders returns all orders where the inventory required to fulfil the order is not
	// available in stock
	UnfulfilableOrders(ctx context.Context, in *UnfulfilableOrdersRequest, opts ...client.CallOption) (*UnfulfilableOrdersResponse, error)
	// FulfilableOrders returns all orders where the inventory required to fulfil the order is
	// available in stock
	FulfilableOrders(ctx context.Context, in *FulfilableOrdersRequest, opts ...client.CallOption) (*FulfilableOrdersResponse, error)
	// List inventory for all products. If ids are provided, only products with these IDs will be returned
	List(ctx context.Context, in *ListRequest, opts ...client.CallOption) (*ListResponse, error)
	// Topup inventory for products
	Topup(ctx context.Context, in *TopupRequest, opts ...client.CallOption) (*TopupResponse, error)
	// Override inventory for products
	Override(ctx context.Context, in *OverrideRequest, opts ...client.CallOption) (*OverrideResponse, error)
}

type inventoryService struct {
	c    client.Client
	name string
}

func NewInventoryService(name string, c client.Client) InventoryService {
	return &inventoryService{
		c:    c,
		name: name,
	}
}

func (c *inventoryService) Reserve(ctx context.Context, in *ReserveRequest, opts ...client.CallOption) (*ReserveResponse, error) {
	req := c.c.NewRequest(c.name, "Inventory.Reserve", in)
	out := new(ReserveResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryService) Pick(ctx context.Context, in *PickRequest, opts ...client.CallOption) (*PickResponse, error) {
	req := c.c.NewRequest(c.name, "Inventory.Pick", in)
	out := new(PickResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryService) Void(ctx context.Context, in *VoidRequest, opts ...client.CallOption) (*VoidResponse, error) {
	req := c.c.NewRequest(c.name, "Inventory.Void", in)
	out := new(VoidResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryService) UnfulfilableOrders(ctx context.Context, in *UnfulfilableOrdersRequest, opts ...client.CallOption) (*UnfulfilableOrdersResponse, error) {
	req := c.c.NewRequest(c.name, "Inventory.UnfulfilableOrders", in)
	out := new(UnfulfilableOrdersResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryService) FulfilableOrders(ctx context.Context, in *FulfilableOrdersRequest, opts ...client.CallOption) (*FulfilableOrdersResponse, error) {
	req := c.c.NewRequest(c.name, "Inventory.FulfilableOrders", in)
	out := new(FulfilableOrdersResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryService) List(ctx context.Context, in *ListRequest, opts ...client.CallOption) (*ListResponse, error) {
	req := c.c.NewRequest(c.name, "Inventory.List", in)
	out := new(ListResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryService) Topup(ctx context.Context, in *TopupRequest, opts ...client.CallOption) (*TopupResponse, error) {
	req := c.c.NewRequest(c.name, "Inventory.Topup", in)
	out := new(TopupResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inventoryService) Override(ctx context.Context, in *OverrideRequest, opts ...client.CallOption) (*OverrideResponse, error) {
	req := c.c.NewRequest(c.name, "Inventory.Override", in)
	out := new(OverrideResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Inventory service

type InventoryHandler interface {
	// Reserve the inventory required to fulfil an order
	Reserve(context.Context, *ReserveRequest, *ReserveResponse) error
	// Pick inventory for an order. If the order was reserved, the units reserved will now be moved
	// to picked.
	Pick(context.Context, *PickRequest, *PickResponse) error
	// Void an order, releasing any inventory reserved or picked for the order.
	Void(context.Context, *VoidRequest, *VoidResponse) error
	// UnfulfilableOrders returns all orders where the inventory required to fulfil the order is not
	// available in stock
	UnfulfilableOrders(context.Context, *UnfulfilableOrdersRequest, *UnfulfilableOrdersResponse) error
	// FulfilableOrders returns all orders where the inventory required to fulfil the order is
	// available in stock
	FulfilableOrders(context.Context, *FulfilableOrdersRequest, *FulfilableOrdersResponse) error
	// List inventory for all products. If ids are provided, only products with these IDs will be returned
	List(context.Context, *ListRequest, *ListResponse) error
	// Topup inventory for products
	Topup(context.Context, *TopupRequest, *TopupResponse) error
	// Override inventory for products
	Override(context.Context, *OverrideRequest, *OverrideResponse) error
}

func RegisterInventoryHandler(s server.Server, hdlr InventoryHandler, opts ...server.HandlerOption) error {
	type inventory interface {
		Reserve(ctx context.Context, in *ReserveRequest, out *ReserveResponse) error
		Pick(ctx context.Context, in *PickRequest, out *PickResponse) error
		Void(ctx context.Context, in *VoidRequest, out *VoidResponse) error
		UnfulfilableOrders(ctx context.Context, in *UnfulfilableOrdersRequest, out *UnfulfilableOrdersResponse) error
		FulfilableOrders(ctx context.Context, in *FulfilableOrdersRequest, out *FulfilableOrdersResponse) error
		List(ctx context.Context, in *ListRequest, out *ListResponse) error
		Topup(ctx context.Context, in *TopupRequest, out *TopupResponse) error
		Override(ctx context.Context, in *OverrideRequest, out *OverrideResponse) error
	}
	type Inventory struct {
		inventory
	}
	h := &inventoryHandler{hdlr}
	return s.Handle(s.NewHandler(&Inventory{h}, opts...))
}

type inventoryHandler struct {
	InventoryHandler
}

func (h *inventoryHandler) Reserve(ctx context.Context, in *ReserveRequest, out *ReserveResponse) error {
	return h.InventoryHandler.Reserve(ctx, in, out)
}

func (h *inventoryHandler) Pick(ctx context.Context, in *PickRequest, out *PickResponse) error {
	return h.InventoryHandler.Pick(ctx, in, out)
}

func (h *inventoryHandler) Void(ctx context.Context, in *VoidRequest, out *VoidResponse) error {
	return h.InventoryHandler.Void(ctx, in, out)
}

func (h *inventoryHandler) UnfulfilableOrders(ctx context.Context, in *UnfulfilableOrdersRequest, out *UnfulfilableOrdersResponse) error {
	return h.InventoryHandler.UnfulfilableOrders(ctx, in, out)
}

func (h *inventoryHandler) FulfilableOrders(ctx context.Context, in *FulfilableOrdersRequest, out *FulfilableOrdersResponse) error {
	return h.InventoryHandler.FulfilableOrders(ctx, in, out)
}

func (h *inventoryHandler) List(ctx context.Context, in *ListRequest, out *ListResponse) error {
	return h.InventoryHandler.List(ctx, in, out)
}

func (h *inventoryHandler) Topup(ctx context.Context, in *TopupRequest, out *TopupResponse) error {
	return h.InventoryHandler.Topup(ctx, in, out)
}

func (h *inventoryHandler) Override(ctx context.Context, in *OverrideRequest, out *OverrideResponse) error {
	return h.InventoryHandler.Override(ctx, in, out)
}
